#중요한 것은 꺾이지 않는 기준. 기준을 일정하게 가져가는 것
import sys
h, *sqrs = map(int, sys.stdin.read().split())

def find_max(s, f, sqr) :   #기준1 : f를 포함하느냐 포함하지 않느냐. 그럴 때에는 함수 안 코드 ex) while문 에서도 f의 기준에 따라 포함 여부를 똑같이 해주는 게 좋다
    if f - s < 1 :          #여기서는 f를 포함 하는 것으로 정했으며,
        return sqr[s]       #따라서 f-s가 1보다 작을 때, 즉 f=s, 원소가 1개일 때는 그 원소 반환(기준1 충족)
    n = (s+f)//2                #가운데 원소를 기준으로 리스트 범위를 반 나눠준다 (분할정복)
    L = find_max(s, n, sqr)     #왼쪽 리스트
    R = find_max(n+1, f, sqr)   #오른쪽 리스트
    #그리고 왼-오에 걸쳐 최댓값이 있을 수 있으므로 중간의 두개의 원소를 무조건 포함하는 최댓값을 찾는다
    m = min(sqr[n], sqr[n+1])   #두 원소 중 더 작은 값을 높이 m으로 두고
    M = m*2                     #넓이(M) = 높이(m)*밑변(2)
    l, r = n, n+1               #왼쪽 기준 포인터 l, 오른쪽 기준 포인터 s
    while r <= f and l >= s:    #기준2 : while문의 범위는 l과 r이 두 포인터 모두 리스트 범위 s,f를 넘기 전까지
        if l-1>=s :             #l이 아직 s보다 크다면(l이 s의 오른쪽에 있다면)(기준2 충족)
            a=sqr[l-1]          #a는 현재 l보다 왼쪽에 있는 원소
        else :                  #그렇지 않은 경우 a = -1
            a =-1
        if r+1<=f :             #r이 아직 f보다 작다면(r이 f의 왼쪽에 있다면)(기준2 충족)
            b = sqr[r+1]        #b는 현재 r보다 오른쪽에 있는 원소 
        else :
            b = -1              #그렇지 않은 경우 b = -1
        m = min(max(a, b), m)   #높이(m)은 a와 b 중 최댓값과 기존 m중 최솟값으로 대체  
        if a > b :
            l-=1                #만약 a가 b보다 크다면 l은 왼쪽, 현재 a의 인덱스로 이동 
        elif a < b :
            r+=1                #만약 b가 a보다 크다면 r은 오른쪽, 현재 b의 인덱스로 이동
        else :
            l-=1                #만약 a와 b의 값이 같다면, l과 r 모두 이동
            r+=1
        M = max(M, m*(r-l+1))   #그리고 새로운 높이(m)와 범위(l~r)에서 넓이를 계산 후 기존 넓이(M)보다 크면 M 대체
    return max(L, R, M)         #각각 범위에서의 최댓값 중 최댓값 반환

print(find_max(0, h-1, sqrs))

'''
    계속 틀린 이유가 l!=s and r!=f로 해서 둘중 하나만 충족 안돼도 l-=1 혹은 r+=1이 계속 실행돼 틀림.
    만약 l!=s로 잡았으면, 그 밑에 -1할 때에는 l==s?인지 한번 걸렀어야 함 안그럼 s보다 더 작은 원소들 계속 갖고 나옴
'''