#2022.12.23 제출(모범답안 참고)
import sys

#재귀함수 중에 메모라이제이션 사용. 
#이전에 계산했던 값은 저장해서 나중에 같은 연산을 생략할 수 있도록 하는 것
#0~20까지 21*21*21개의 값을 저장할 수 있도록 리스트를 만들어주는데 형태는 [[[[0]*21]*21]*21]
#[0]*21 하면 [0, 0, 0, ... , 0]이고 
#for _ in range(21)하면 [0, ..., 0][0, ..., 0]...[0, ..., 0] 형태로 반복됨
d = [[[0]*21 for _ in range(21)]for _ in range(21)]

def w(a:int,b:int,c:int) -> int :
    #a,b,c 중 하나라도 0이하이면 1 반환
    if a <= 0 or b <= 0 or c <= 0 :
        return 1
    #a,b,c 중 하나라도 20초과면 w(20, 20, 20 반환)
    elif a > 20 or b > 20 or c > 20 :
        return w(20, 20, 20)
    #리스트 d에서 모든 원소의 값은 0이고, 연산 후에는 w(x,y,z)형태로 되어있음 (like 피보나치 수열)
    #따라서 원소 값이 0이 아닌 경우 해당 값을 리턴해줘야함 (안그러면 0으로 무한 반복)
    if(d[a][b][c] !=0 ):
        return d[a][b][c]
    #a<b<c라면 다음과 같이 계산. 이때 리스트에 d[a][b][c] 원소에 값을 저장해 같은 연산 반복을 줄임
    if a < b < c:
        d[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)
    #a||b||c <=0 or a||b||c > 20 or a<b<c가 아닐 때의 연산.
    #마찬가지로 d[a][b][c]에 값 저장
    d[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
    return d[a][b][c]

#조금이라도 효율을 높이기 위해 출력을 맨 마지막으로 빼주기 위해 answer리스트와 join 함수 사용
answer = []
while True :
    a,b,c = map(int, sys.stdin.readline().split())      #입력 받기
    if a == b == c == -1 :
        break       #문제 조건에서 마지막 줄은 a=b=c=-1이므로 이때 while문 탈출
    #출력형식에 맞게 answer함수에 원소로 삽입. 이때 답 부분에 w(a,b,c)를 넣어 w함수 호출
    v=w(a,b,c)
    print(f'w({a}, {b}, {c}) = {v}')