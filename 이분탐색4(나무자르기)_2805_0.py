import sys
'''
N : 허가 받은 나무의 수 
M : 필요한 나무 최소 길이
T : 각 나무의 길이
'''
N, M, *T = map(int, sys.stdin.read().split())

def search(min_h, max_h):
    if max_h - min_h <= 1 : #최솟값과 최댓값의 차이가 1이하면 최솟값 반환
        print(min_h)
        return None
    get = 0 #자른 후 가져갈 수 있는 나무의 길이 (카운트 변수)
    h = (min_h+max_h)//2    #h:중위 값
    for x in T :
        if x > h :
            get += (x-h)    # h보다 큰 나무만 자름
    if get >= M :
        search(h, max_h)    #자른 나무의 길이(get)가 필요한 길이(M)보다 같거나 긴 경우 h를 더 높여야 함 (같은 경우에는 h의 최댓값을 찾아야 하므로)
    else :
        search(min_h,h)     #자른 나무의 길이(get)가 필요한 길이(M)보다 짧은 경우 h를 줄여야 함

search(0, max(T)+1) #탐색 시작 시 최솟값은 0, 최댓값은 최대 원소의 크기+1 (최솟값이상 최댓값 미만으로 최댓값은 포함 안되므로)

#이분탐색을 이전에는 최솟값이상 최댓값이하로 한후 최솟값>최댓값으로 값이 뒤집히는 경우 최댓값을 반환했는데 이 로직은 나에게 직관적으로 와닿지는 않는다
#그래서 최솟값이상 최댓값미만으로 로직을 짰는데, 이거는 사실 중간 과정(최댓값 불포함, 재귀함수 시 중위값에+-1 안하는 것)은 이해되지 않지만, 값 반환 시 최솟값을 반환하는 것은 이해돼서 이렇게 함
#그러나 아직도 왜 두 방법이 이렇게 다르게 하는지, 이해 안감. 걍 외워서 푸는 중